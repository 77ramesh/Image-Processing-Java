package com.java_face_detection;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.videoio.VideoCapture;

//using open CV and my own algorithms
public class LiveVideoEdgeDetector {
	
	static int n0, n1, n2, n3, n4, n5, n6, n7, n8;
	
	public static void main(String[] args) throws Exception {
		
		BufferedImage src = ImageIO.read(new File("C:\\Users\\Ramesh\\Desktop\\opencv\\mack.jpg"));
		
		ImageIO.write(gussianBlur(src), "jpg", new File("C:\\Users\\Ramesh\\Desktop\\out.jpg"));
	}
	
	
	//open CV starts video start directly from web camera
	static void startVideoStream() throws Exception {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
		
		Mat frame = new Mat();
	    //0; default video device id
	    VideoCapture camera = new VideoCapture(0);
	    JFrame jframe = new JFrame("Title");
	    jframe.setSize(500, 500);
	    jframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	    JLabel vidpanel = new JLabel();
	    vidpanel.setSize(500, 500);
	    jframe.setContentPane(vidpanel);
	    jframe.setVisible(true);

	    while (true) {
	        if (camera.read(frame)) {

	            ImageIcon image = new ImageIcon(Mat2BufferedImage(frame));
	            vidpanel.setIcon(image);
	            vidpanel.repaint();

	        }
	    }
	}
	
	
	
	//converting the matrix generated by open CV to buffered image
	static BufferedImage Mat2BufferedImage(Mat matrix)throws Exception {        
	    MatOfByte mob = new MatOfByte();
	    Imgcodecs.imencode(".jpg", matrix, mob);
	    byte ba[] = mob.toArray();

	    BufferedImage bi = ImageIO.read(new ByteArrayInputStream(ba));
	    
	    return grayScale(bi);
	}
	
	
	
	static BufferedImage gussianBlur(BufferedImage src) throws IOException {
		
		float[] matrix = {
			    1/16f, 1/8f, 1/16f, 
			    1/8f, 1/4f, 1/8f, 
			    1/16f, 1/8f, 1/16f, 
			};
		
		BufferedImage out = new BufferedImage(src.getWidth(), src.getHeight(), src.getType());
		
		Kernel kernel = new Kernel(3, 3, matrix);
		BufferedImageOp op = new ConvolveOp(kernel);
		out = op.filter(src, out);
		
		return grayScale(out);
	}
	
	
	
	//convert image to black and white
	static BufferedImage grayScale(BufferedImage src) throws IOException {
		
		BufferedImage out = new BufferedImage(src.getWidth(), src.getHeight(), src.getType());
		
		for(int y=0;y<src.getHeight();y++) {
			for(int x=0;x<src.getWidth();x++) {
				
				Color color = new Color(src.getRGB(x, y));
				
				int R = (int) (color.getRed() * 0.3);
				int G = (int) (color.getGreen() * 0.5);
				int B = (int) (color.getBlue() * 0.1);
				
				Color newColor = new Color(R+G+B, R+G+B, R+G+B);
				
				out.setRGB(x, y, newColor.getRGB());
				
			}
			
		}
		
		return edges(out);
	}
	
	
	
	//finds the edges of image using sobel kernel
	static BufferedImage edges(BufferedImage src) {
		
		BufferedImage out = new BufferedImage(src.getWidth(), src.getHeight(), src.getType());
		
		for(int y=1;y<src.getHeight()-1;y++) {
			for(int x=1;x<src.getWidth()-1;x++) {
			
				knn(src, x, y);
				
				out.setRGB(x, y, calcAvrg());
			}
		}
		
		return out;
	}
	
	
	//applying kernels
	static void knn(BufferedImage src, int x, int y) {
		
		int[][] filter1 = {
				{0, -1, 0},
				{-1, 4, -1},
				{0, -1, 0}
		};
		
		int[][] filter2 = {
				{-1, 0, 1},
				{-2, 0, 2},
				{-1, 0, 1}
		};
		
		//parent
		n0 = src.getRGB(x, y) * filter2[1][1];
		n1 = src.getRGB(x, y+1) * filter2[2][1];
		//n2 = src.getRGB(x-1, y+1) * filter2[2][0];//0
		n3 = src.getRGB(x-1, y) * filter2[1][0];
		//n4 = src.getRGB(x-1, y-1) * filter2[0][0];//0
		n5 = src.getRGB(x, y-1) * filter2[0][1];
		//n6 = src.getRGB(x+1, y-1) * filter2[0][2];//0
		n7 = src.getRGB(x+1, y) * filter2[1][2];
		//n8 = src.getRGB(x+1, y+1) * filter2[2][2];//0
	}
	
	static int calcAvrg() {
		return (n0+n1+n3+n5+n7);
	}

}
